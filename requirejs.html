<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta http-equiv="Pragma" content="no-cache">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0">
    <title>RequireJS</title>
    <link type="text/css" rel="stylesheet" href="./3rd/SyntaxHighlighter/styles/shCoreRDark.css"/>
    <link type="text/css" rel="stylesheet" href="./css/semantic.min.css"/>
    <link type="text/css" rel="stylesheet" href="./css/lib.css"/>
</head>
<body>
    <div class="ui fluid container icontainer">
        <div class="ui large centered header">RequireJS</div>
        <div class="ui horizontal divider">第二讲</div>

        <div class="ui warning message">
            <a href='http://requirejs.org/' target="_blank">RequireJS</a> 一个模块化加载工具。
            <p>RequireJS的目标是鼓励代码的模块化，它使用了不同于传统&lt;script&gt;标签的脚本加载步骤。可以用它来加速、优化代码，但其主要目的还是为了代码的模块化。它鼓励在使用脚本时以module ID替代URL地址。</p>
            <p><a href='http://requirejs.org/docs/api.html' target='_blank'>文档</a></p>
            <p><a href='http://www.requirejs.cn/docs/api.html' target='_blank'>文档(中文)</a></p>
        </div>
        <br/>


        <div class="ui segment">
            <div class="ui large header">开始</div>
            <div class="ui divider"></div>
            RequireJS以一个相对于baseUrl的地址来加载所有的代码。 页面顶层&lt;script&gt;标签含有一个特殊的属性data-main，require.js使用它来启动脚本加载过程，而baseUrl一般设置到与该属性相一致的目录。下列示例中展示了baseUrl的设置：
            <pre class="brush: js;">
                <!--This sets the baseUrl to the "scripts" directory, and
                loads a script that will have a module ID of 'main'-->
                <script data-main="scripts/main.js" src="scripts/require.js"></script>
            </pre>
            <p>baseUrl亦可通过RequireJS config手动设置。如果没有显式指定config及data-main，则默认的baseUrl为包含RequireJS的那个HTML页面的所属目录。</p>

            <p>index.html:</p>
            <pre class="brush: js;">
                <script data-main="js/app.js" src="js/require.js"></script>
            </pre>
            <p>app.js:</p>
            <pre class="brush: js;">
                requirejs.config({
                    //By default load any module IDs from js/lib
                    baseUrl: 'js/lib',
                    //except, if the module ID starts with "app",
                    //load it from the js/app directory. paths
                    //config is relative to the baseUrl, and
                    //never includes a ".js" extension since
                    //the paths config could be for a directory.
                    paths: {
                        app: '../app'
                    }
                });

                // Start the main app logic.
                requirejs(['jquery', 'canvas', 'app/sub'],
                    function($, canvas, sub) {
                    //jQuery, canvas and the app/sub module are all
                    //loaded and can be used here now.
                });
            </pre>
            理想状况下，每个加载的脚本都是通过define()来定义的一个模块；但有些"浏览器全局变量注入"型的传统/遗留库并没有使用define()来定义它们的依赖关系，你必须为此使用shim config来指明它们的依赖关系。 如果你没有指明依赖关系，加载可能报错。这是因为基于速度的原因，RequireJS会异步地以无序的形式加载这些库。

        </div><br/>


        <div class="ui segment">
            <div class="ui large header">data-main</div>
            <div class="ui divider"></div>
            require.js 在加载的时候会检察data-main 属性。<br/>
            你可以在data-main指向的脚本中设置模板加载 选项，然后加载第一个应用模块。.注意：你在main.js中所设置的脚本是异步加载的。所以如果你在页面中配置了其它JS加载，则不能保证它们所依赖的JS已经加载成功。<br/>
            如下：
            <pre class="brush: js;">
                <script data-main="scripts/main" src="scripts/require.js"></script>
                <script src="scripts/other.js"></script>
            </pre>
            <pre class="brush: js;">
                // contents of main.js:
                require.config({
                    paths: {
                        foo: 'libs/foo-1.1.3'
                    }
                });
            </pre>
            <pre class="brush: js;">
                // contents of other.js:

                // This code might be called before the require.config() in main.js
                // has executed. When that happens, require.js will attempt to
                // load 'scripts/foo.js' instead of 'scripts/libs/foo-1.1.3.js'
                require( ['foo'], function( foo ) {

                });
            </pre>

        </div><br/>


        <div class="ui segment">
            <div class="ui large header">AMD</div>
            <div class="ui divider"></div>
            RequireJS 遵循 AMD 语法，模块是异步加载的，所以我们常规需要使用 define 函数来定义回调。<br/>
            AMD是在CommonJS的基础上考虑了浏览器的异步加载特性而产生的，可以让模块异步加载并保证执行顺序。
            <pre class="brush: js;">
                define(['a'], function(a){
                    return {
                        foo: a.foo
                    };
                });
            </pre>
        </div><br/>

        <p>以下看文档，看文档，看文档。。。</p>
        <p><a href='http://requirejs.org/docs/api.html' target='_blank'>文档</a></p>
        <p><a href='http://www.requirejs.cn/docs/api.html' target='_blank'>文档(中文)</a></p>

    </div>

    <script type="text/javascript" src="./js/jquery-2.2.0.min.js"></script>
    <script type="text/javascript" src="./3rd/SyntaxHighlighter/scripts/shCore.js"></script>
    <script type="text/javascript" src="./3rd/SyntaxHighlighter/scripts/shAutoloader.js"></script>
    <script type="text/javascript" src="./3rd/dist/semantic.min.js"></script>
    <script type="text/javascript">
        $(document).ready(function(){
            SyntaxHighlighter.autoloader(
                ['js','jscript','javascript','3rd/SyntaxHighlighter/scripts/shBrushJScript.js'],
                ['bash','shell','3rd/SyntaxHighlighter/scripts/shBrushBash.js'],
                ['css','3rd/SyntaxHighlighter/scripts/shBrushCss.js'],
                ['xml','html','3rd/SyntaxHighlighter/scripts/shBrushXml.js'],
                ['sql','3rd/SyntaxHighlighter/scripts/shBrushSql.js'],
                ['php','3rd/SyntaxHighlighter/scripts/shBrushPhp.js'],
                ['java','3rd/SyntaxHighlighter/scripts/shBrushJava.js'],
                ['groovy','3rd/SyntaxHighlighter/scripts/shBrushGroovy.js']
            );
            SyntaxHighlighter.config.bloggerMode = true;
            SyntaxHighlighter.defaults['toolbar'] = false;
            SyntaxHighlighter.all(); 
        })
    </script>
</body>
</html>


